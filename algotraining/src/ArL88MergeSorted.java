/**
 * 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
 *请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
 *注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，
 * 其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
 * @date 2023/12/27 10:16
 */
public class ArL88MergeSorted {
    /*合并两个非递减数组 结果保存到1中 上来凭经验就知道肯定可以用双指针方法原地解决这个问题 但是把i,j,k都指向开头后
    代码写完运行才发现会有覆盖的问题 所以本题是要把指针指向数组结尾 不会产生覆盖问题 因为nums后面留了n个空格
    所以再怎么也不会出现k<i的情况 以后遇到双指针的问题把指针指向数组开头之前要考虑下会不会出现覆盖
    不能覆盖指的是 当结果是在原始数组里依次从前往后存的时候 结果索引下标k要一直在原始数组索引下标i前面
    当结果是从后往前存的时候 结果索引下标k要一直在原始数组索引下标i后面 才能保证不会影响到还没处理的元素
    */
    public void merge(int[] nums1,int m,int[] nums2,int n){
//        if (n == 0) {
//            return;
//        } //最开始想到的方法结束出口先写下来 代码写完后因为此时已经清楚了算法逻辑再看一下这个出口还有没有必要
        int i = m - 1, j = n - 1, k = m + n - 1;
        while (i >= 0 && j >= 0) {
            // if (nums1[i] >= nums2[j]) {
            //     nums1[k--] = nums1[i--];
            // } else {
            //     nums1[k--] = nums2[j--];
            // }
            nums1[k--]=(nums1[i]>=nums2[j])?nums1[i--]:nums2[j--];
        }

//        只需要额外考虑数组2还有剩余的情况 因为如果数组1剩余 此时i肯定等于k 不用移了
        while (j >= 0) {
            nums1[k--] = nums2[j--];
        }
    }
}
